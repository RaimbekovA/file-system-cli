import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Comparator;

class MyFile {
    public static void listDirectory(String path) {
        try {
            if (path != null) {
                Files.list(Paths.get(path)).forEach(System.out::println);
            } else {
                System.out.println("Please specify the path to the directory.");
            }
        } catch (IOException e) {
            System.out.println("Error reading the directory: " + e.getMessage());
        }
    }

    public static void listPythonFiles(String path) {
        try {
            Files.list(Paths.get(path))
                    .filter(p -> p.toString().endsWith(".py"))
                    .forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("Error reading directory: " + e.getMessage());
        }
    }

    public static void isDirectory(String path) {
        System.out.println(Files.isDirectory(Paths.get(path)));
    }

    public static void define(String path) {
        Path p = Paths.get(path);
        if (Files.isDirectory(p)) {
            System.out.println("Directory");
        } else if (Files.isRegularFile(p)) {
            System.out.println("File");
        } else {
            System.out.println("unknown");
        }
    }

    public static void printPermissions(String path) {
        try {
            DosFileAttributes attr = Files.readAttributes(Paths.get(path), DosFileAttributes.class);
            System.out.println("Readable: " + attr.isReadOnly());
            System.out.println("Writable: " + !attr.isReadOnly());
            System.out.println("Executable: " + !attr.isReadOnly());
        } catch (IOException e) {
            System.out.println("Error reading permissions: " + e.getMessage());
        }
    }

    public static void setPermissions(String path, String permissions) {
        try {
            Path file = Paths.get(path);
            if (permissions.equalsIgnoreCase("readonly")) {
                Files.setAttribute(file, "dos:readonly", true);
                System.out.println("Permissions set to read-only for file: " + path);
            } else if (permissions.equalsIgnoreCase("writable")) {
                Files.setAttribute(file, "dos:readonly", false);
                System.out.println("Permissions set to writable for file: " + path);
            } else if (permissions.equalsIgnoreCase("executable")) {
                // There is no direct "executable" attribute for the Windows platform
                // But we can set the "system" attribute, which will give the file the right to execute
                Files.setAttribute(file, "dos:system", true);
                System.out.println("Permissions set to executable for file: " + path);
            } else {
                System.out.println("Invalid mode.");
            }
        } catch (IOException e) {
            System.out.println("Error setting permissions: " + e.getMessage());
        }
    }

    public static void printContent(String path) {
        try {
            Files.lines(Paths.get(path)).forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
    }

    public static void appendFooter(String path) {
        try {
            Files.write(Paths.get(path), "\n# Autogenerated line".getBytes(), StandardOpenOption.APPEND);
        } catch (IOException e) {
            System.out.println("Error appending to file: " + e.getMessage());
        }
    }

    public static void createBackup(String path) {
        try {
            // Getting the path to the project
            String projectPath = System.getProperty("user.dir");
            // Creating a tmp folder inside the project, if it doesn't exist yet
            Files.createDirectories(Paths.get(projectPath, "tmp"));
            // Creating a backup folder with the current date
            String backupFolder = LocalDate.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy"));
            Path backupPath = Paths.get(projectPath, "tmp", backupFolder);
            Files.createDirectories(backupPath);
            // We copy the contents of the file or directory to a backup copy
            Path sourcePath = Paths.get(path);
            Path targetPath = Paths.get(backupPath.toString(), sourcePath.getFileName().toString());
            if (Files.isDirectory(sourcePath)) {
                // If the source path is a directory, copy all the contents
                Files.walkFileTree(sourcePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (!file.getFileName().toString().equalsIgnoreCase("desktop.ini")) {
                            // Skipping copying desktop.ini
                            Path targetFile = targetPath.resolve(sourcePath.relativize(file));
                            Files.copy(file, targetFile, StandardCopyOption.REPLACE_EXISTING);
                        }
                        return FileVisitResult.CONTINUE;
                    }
                });
            } else {
                // If the source path is a file, just copy it
                Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
            }
            System.out.println("Backup created at: " + targetPath);
        } catch (IOException e) {
            System.out.println("Error creating backup: " + e.getMessage());
        }
    }

    public static void printLongestWord(String path) {
        try {
            String longestWord = Files.lines(Paths.get(path))
                    .flatMap(line -> Arrays.stream(line.split("\\s+")))
                    .max(Comparator.comparingInt(String::length))
                    .orElse("");
            System.out.println(longestWord);
        } catch (IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
    }

    public static void helpEnglish() {
        System.out.println("ls <path>               - displays a list of all files and directories for `path`");
        System.out.println("ls_py <path>            - displays a list of files with the `.py` extension in `path`");
        System.out.println("is_dir <path>           - outputs `true` if `path` is a directory, otherwise `false`");
        System.out.println("define <path>           - outputs `directory` or `file` depending on the type of `path`");
        System.out.println("readmod <path>          - displays the permissions for the file in `rwx` format for the current user");
        System.out.println("setmod <path> <perm>    - sets permissions for the `path` file");
        System.out.println("cat <path>              - outputs the content of the file");
        System.out.println("append <path>           - adds the line `# Autogenerated line` to the end of `path`");
        System.out.println("bc <path>               - creates a copy of `path` in the directory `/tmp/${date}.backup` where date is the date in the format `dd-mm-yyyy`");
        System.out.println("greplong <path>         - outputs the longest word in the file");
        System.out.println("help                    - displays a list of commands and their description");
        System.out.println("exit                    - exits the program");
    }

    public static void helpRussian() {
        System.out.println("ls <path>               - выводит список всех файлов и директорий для `path`");
        System.out.println("ls_py <path>            - выводит список файлов с расширением `.py` в `path`");
        System.out.println("is_dir <path>           - выводит `true`, если `path` это директория, в других случаях `false`");
        System.out.println("define <path>           - выводит `директория` или `файл` в зависимости от типа `path`");
        System.out.println("readmod <path>          - выводит права для файла в формате `rwx` для текущего пользователя");
        System.out.println("setmod <path> <perm>    - устанавливает права для файла `path`");
        System.out.println("cat <path>              - выводит контент файла");
        System.out.println("append <path>           - добавляет строку `# Autogenerated line` в конец `path`");
        System.out.println("bc <path>               - создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`");
        System.out.println("greplong <path>         - выводит самое длинное слово в файле");
        System.out.println("help                    - выводит список команд и их описание");
        System.out.println("exit                    - завершает работу программы");
    }

    public static void exit() {
        System.out.println("Goodbye");
    }
}
